### AVL 树

平衡因子 Balance Factor：

- 一个节点的左子树的高度减去他的右子树的高度。

AVL 树

- 任意节点的平衡因子的绝对值不超过 1，即 Balance Factor 属于 {-1,0,1}
- 每个节点需要保存：原始数据、左子结点、右子结点、子树高度

AVL 树在插入、删除时，沿途更新节点的高度值，当平衡因子的绝对值大于 1 时，触发树结构的修正，通过旋转操作来进行平衡。

### 红黑树

红黑树（Red-black Tree）是一种近似平衡二叉搜索树

- 从根到叶子的最长路径<= 2 \* 最短路径（简记：高度差在 2 倍以内）

规则：

- 每个节点要么是红色，要么是黑色
- 根节点是黑色
- 最底层视作右一层空节点，也是黑色的
- 不能有两个相邻的红色节点
- 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

规则打破时，通过变色或者旋转操作来修正

相比 AVL 树，红黑树插入删除更快（旋转少）、更省空间（颜色 vs 平衡因子）
查询稍慢（不如 AVL 树更加平衡）

红黑树是许多语言中有序集合、有序映射的内部实现方式。

#### 随机的艺术

在数据足够多的情况下，“随机”就是最自然、趋于平衡的

- 快速排序“随机”选取中轴（pivot），按大小分成两半，期望层数 O(logN)
- 在一条数轴上随机撒点、点的期望分布是均匀的
- 跳表通过随机来选取索引元素，一级决定是否更新索引
- 把一组随机数据插入二叉搜索树（BST），期望是平衡的，即 O(logN)层

对 BST 的节点进行旋转，不影响数据的有序性，可以让树变得更加平衡
问题：如何决定要不要旋转？
思路：产生一组额外的随机数据，让他们满足某种性质，从而形成一个趋于平衡的树结构

### Treap = Tree + Heap

树堆（Treap）的每个节点保存两个值

- 原始数据，也叫关键码
- 额外的权值，是随机生成的

树堆首先是一颗二叉搜索树，节点的关键码（原始数据）满足 BST 性质：左<=根<=右
树堆也是一个堆，节点的额外权值满足大根堆形式：父>=子

Treap 各项操作的时间复杂度均为 O(logN)
Treap 检索、求前驱、求后继的操作与普通 BST 一致-- 一次递归查询

#### 插入/删除（与 BST 不一样）

Treap 先通过类似于 BST 的检索，找到需要插入新节点的位置
插入后，给新节点随机生成一个额外的权值
然后像二叉堆的插入过程一样，自底向上依次检查，当某个节点不满足大根堆性质时，就执行单旋转，使该点与其父节点的关系发生对换

删除时，首先通过检索找到需要删除的节点
由于 Treap 支持旋转，可以把需要删除的节点向下旋转成叶节点，最后直接删除。非常简便，避免了 BST 删除操作对各种情况的讨论，也避免了维护堆性质。
